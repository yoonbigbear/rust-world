# 스레드 생성
러스트는 `std::thread::spawn`에 클로저나 함수를 전달해서 새로운 스레드를 시작할 수 있다.  
이때 클로저에 `move` 키워드를 사용하면 소유권을 클로저로 이동하게 되고, 그렇지 않으면 **기본 값으로 레퍼런스로 캡처**한다. 레퍼런스로 캡처할 때 주의할 점은 스레드가 레퍼런스의 원본보다 라이프 타임이 더 길다면, 컴파일 에러를 발생시킨다.  
`std::thread::spawn`으로 생성하는 스레드는 프로그램이 종료될 때까지 계속 실행될 수 있기 때문에 항상 static life time을 갖는 타입을 입력받는다.  
예를 들어 다음 코드는 컴파일 에러를 발생시킨다.
```rust
fn main() {
let non_static_value = 42;
        thread::spawn(|| {
            for i in 0..10 {
                println!("{}", i + non_static_value);
                thread::sleep(Duration::from_millis(10));
            }
        });
}
```
![alt text](image.png)  

# 스레드 기다리기
스레드는 main 함수가 종료되면 다른 스레드들이 실행 중이더라도 프로그램을 종료한다.  
이를 막으러면 스레드가 종료될 때까지 스레드를 기다려야 한다. 그러기 위해서는 spawn에서 받은 `JoinHandle`을 사용해야 한다.
다음의 코드는 spawn된 스레드가 종료될 때까지 메인 스레드에서 `join`을 호출해서 동기적으로 기다린다.
```rust
fn main() {
    let t1 = std::thread::spawn(||{
        std::thread::sleep(Duration::from_secs(1));
        println!("Hello, world!");
    });
    
    t1.join().unwrap();
}
```
만약 스레드에서 패닉이 발생했다면 `join`은 패닉메시지를 포함시킨다.
다음의 코드는 Thread pacicked가 stack trace와 함께 출력된다.
```rust
fn main() {
    let t1 = std::thread::spawn(||{
        panic!("Panic");
    });
    
    // handle panic
    let result = t1.join();
    if let Err(e) = result {
        println!("Thread panicked: {:?}", e);
    }
}
```
![alt text](image-1.png)

> 만약 클로저가 값을 반환한다면, thread의 join에서 그 값을 받을 수 있다.  

> std::thread::spawn은 정확히는 std::thread::Builder::new().spawn().unwrap()을 간편하게 사용하기 위한 형태이다. `Builder`를 사용하면 스레드의 스택 메모리 크기를 지정하거나, 이름을 붙히는 등 다양한 설정을 할 수 있다.

> println! 매크로는 내부에서 std::io::Stdout::lock()을 통해 출력 결과를 스레드 세이프하게 만든다.

# 스레드 수명 제한하기
`std::thread::spawn`는 `'static` 라이프 타임을 가진다. 하지면 특정 범위에서만 존재할 수 있도록 `std::thread::scope`를 제공한다.  
scope는 범위 안에만 존재하기 떄문에 로컬 변수의 소유권을 빌려올 수 있다. 이 패턴을 사용하면 **스레드가 범위 밖으로 나가지 못하는 것이 보장**되어 `'static`이 아닌 인수도 받을 수 있게 된다.
다음의 예는 spawn으로 생성했을 때 컴파일 에러가 발생했었지만 scope를 사용해서 문제를 해결했다.
```rust
fn main() {
    let non_static_value = 42;
    std::thread::scope(|s| {
        for i in 0..10 {
            println!("{}", i + non_static_value);
            std::thread::sleep(Duration::from_millis(10));
        }
        
        s.spawn(|| {
            for i in 0..10 {
                println!("{}", i + non_static_value);
                std::thread::sleep(Duration::from_millis(10));
            }
        });
    });
}
```
scope는 현재 범위를 나타내는 인수를 받는다. 위의 예는 s를 말한다.  
이 인수를 사용해 spawn을 호출하면 스레드의 범위도 scope 범위 안에서만 존재하도록 제한 할 수 있다.  
위 예제에서는 non_static_value가 불변이기 때문에 동시에 접근 하는 것이 가능하다. 하지만 만약 mutable이었을 경우 컴파일 오류가 발생한다.
![alt text](image-2.png)

# 스레드의 자원 공유
static 변수는 특정 스레드에 종속되지 않는 변수를 만들 수 있다. static 변수는 프로그램 자체가 소유권을 가진다.  
static 변수는 일정한 Initializer를 가지며 프로그램이 시작되기 전에 생성된다.  
값의 할당을 누수하는 것도 방법이 될 수 있다. `Box::leak`함수를 사용하면 Box의 소유권을 해제하고 값이 드랍되지 않게 할 수 있다. 누수된 값은 프로그램이 종료될 때까지 존재하게 된다.
```rust
    let x: &'static [i32; 3] = Box::leak(Box::new([1, 2, 3]));

    thread::spawn(move || dbg!(x));
    thread::spawn(move || dbg!(x));
```
하지만 이름에서 알 수 있다시피 누구시키면 메모리가 누수된다.  

스레드 사이에서 데이터를 공유하기 위한 가잫 좋은 방법은 **소유권을 공유**하는 것이다. 이를 레퍼런스 카운팅이라고 한다.  
```rust
    let a = Rc::new([1,2,3]);
    let b = a.clone(); // 레퍼런스 카운트가 증가한다.
    assert_eq!(a.as_ptr(), b.as_ptr());
```
스레드 안정성이 보장되는 레퍼런트 타입이 필요할 경우에는 std::sync::Arc를 사용하면 된다.
주의해야 할 점은 일반 레퍼런스`&T` 처럼 다른 코드에서 소유권을 대여하고 있으면 원래 값의 수정이 불가능하다. 이는 레퍼런트 카운팅 포인터도 마찬가지다.

# 스레드 사이의 소유권 대여
러스트에서 값을 빌리는 방법은 두 가지가 있는데 하나는 `&`로 불변 레퍼런스로 받아오는 방법과, `&mut`로 가변 레퍼런스를 대여하는 방법이 있다.  
불변 레퍼런스의 경우 불변 레퍼런스를 통해 값을 바꾸는 걸 허용하지 않는다. 반대로 가변 레퍼런스는 값을 바꾸는게 가능하다. 그리고 가변 레퍼런스는 한 번에 하나의 가변 레퍼런스만 대여가 가능하다.  
러스트는 소유권 대여를 통해 스레드간의 동기화를 유지한다.

# 내부 가변성
소유권 대여 규칙만으로는 멀티스레드 환경에서 명확한 한계점이 존재한다. 컴파일 단계부터 실패하기 때문에 정보 교환도 제한적이고 혹은 불가능한 정도이기도 하다.  
이럴때 내부 가변성을 사용해서 이 문제를 해결할 수 있다. 내부 가변성은 특종 조건이 만족하는 경우에는 **불편 레퍼런스를 사용해 참조하는 값을 변경**할 수 있도록 한다.  
### Cell
Cell은 공유 레퍼런스로 값을 변경할 수 있는 타입이다. 단일 스레드에서만 사용 가능한 타입이다
```rust
fn f (a: &Cell<i32>, b: &Cell<i32>) {
    let before = a.get();
    b.set(b.get()+1);
    let after = a.get();
    if before != after {
        println!("a changed from {} to {}", before, after); // 실핼될 수도 있다.
    }
}
```
Cell의 내부 가변성 때문에 컴파일러가 더 이상 변수의 값이 변하지 않는다고 보장하지 못한다. 그래서 컴파일에 성공한다.
### RefCell
Cell은 값을 수정하려면 꺼내서 수정하고 다시 담아야 했다. 하지만 **RefCell은 내부의 값을 대여**할 수 있다.  
RefCell은 내부적으로 몇 번 대여했는지 추적해서 런타임에 불변성을 검증하는 방식이다. 하지만 RefCell도 런타임에 안전하지 못하다

### RwLock
RefCell의 동시성 버전으로, RefCell에서 패닉을 일으키며 동작을 막는 것과 다르게, 현재 스레드를 차단시킨다.  

### Mutex
RwLock보다 조금 더 간단하다. RwLock처럼 내부에서 대여가 몇 번 일어났는지 추적하지 않고 독점적 소유만 허용한다.

### 아토믹
아토믹은 Cell의 동시성 버전으로 값을 대여하지 않고 복사한다.  
아토믹 타입의 크기는 제한되어있기 때문에 여러 스레드에서 값이 공유될 수 있도록 도구로서의 역할을 수행한다.

# Thread safe 타입
러스트에서는 Send와 Sync를 통해 멀티스레드에서 안정성을 보장한다.  
Send는 소유권을 다른 스레드로 이전할 수 있음을 의미하고, Sync는 여러 스레드에 공유될 수 있음을 의미한다.  
예를 들어 thread::spawn 함수는 인수가 모두 Send트레이트를 구현해야 하며, 클로저는 모든 변수가 Send트레이트를 구현하는 경우에만 클로저가 Send트레이트를 구현할 수 있다.

### 러스트의 뮤텍스
러스트의 뮤텍스는 lock을 호출하면 MutexGuard를 반환한다. MutexGuard를 반환 받으면 현재 뮤텍스가 잠겼음을 의미한다.  
그리고 MutexGuard가 드랍될 때 뮤텍스의 잠금이 해제된다.  
만약 잠금을 획득한 상태에서 패닉이 발생하면 뮤텍스가 오염되었다고 한다. 이 상태가 되면 뮤텍스는 더이상 잠금 상태가 아니지만 만약 다른 스레드에서 lock을 호출하면 Err를 리턴해서 오염 상태를 알린다.  
Err를 받은 스레드는 예외 상황을 처리할 수 있다.  
오염된 뮤텍스에서 lock을 호출하더라도 뮤텍스는 계속 잠금 상태가 된다.
> 만약 뮤텍스 가드를 선언하지 않고 사용하면 불필요하게 잠금 범위가 커질 수 있다.

### 
