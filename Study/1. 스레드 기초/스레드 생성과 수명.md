# 스레드 생성
러스트는 `std::thread::spawn`에 클로저나 함수를 전달해서 새로운 스레드를 시작할 수 있다.  
이때 클로저에 `move` 키워드를 사용하면 소유권을 클로저로 이동하게 되고, 그렇지 않으면 **기본 값으로 레퍼런스로 캡처**한다. 레퍼런스로 캡처할 때 주의할 점은 스레드가 레퍼런스의 원본보다 라이프 타임이 더 길다면, 컴파일 에러를 발생시킨다.  
`std::thread::spawn`으로 생성하는 스레드는 프로그램이 종료될 때까지 계속 실행될 수 있기 때문에 항상 static life time을 갖는 타입을 입력받는다.  
예를 들어 다음 코드는 컴파일 에러를 발생시킨다.
```rust
fn main() {
let non_static_value = 42;
        thread::spawn(|| {
            for i in 0..10 {
                println!("{}", i + non_static_value);
                thread::sleep(Duration::from_millis(10));
            }
        });
}
```
![alt text](image.png)  

# 스레드 기다리기
스레드는 main 함수가 종료되면 다른 스레드들이 실행 중이더라도 프로그램을 종료한다.  
이를 막으러면 스레드가 종료될 때까지 스레드를 기다려야 한다. 그러기 위해서는 spawn에서 받은 `JoinHandle`을 사용해야 한다.
다음의 코드는 spawn된 스레드가 종료될 때까지 메인 스레드에서 `join`을 호출해서 동기적으로 기다린다.
```rust
fn main() {
    let t1 = std::thread::spawn(||{
        std::thread::sleep(Duration::from_secs(1));
        println!("Hello, world!");
    });
    
    t1.join().unwrap();
}
```
만약 스레드에서 패닉이 발생했다면 `join`은 패닉메시지를 포함시킨다.
다음의 코드는 Thread pacicked가 stack trace와 함께 출력된다.
```rust
fn main() {
    let t1 = std::thread::spawn(||{
        panic!("Panic");
    });
    
    // handle panic
    let result = t1.join();
    if let Err(e) = result {
        println!("Thread panicked: {:?}", e);
    }
}
```
![alt text](image-1.png)

> 만약 클로저가 값을 반환한다면, thread의 join에서 그 값을 받을 수 있다.  

> std::thread::spawn은 정확히는 std::thread::Builder::new().spawn().unwrap()을 간편하게 사용하기 위한 형태이다. `Builder`를 사용하면 스레드의 스택 메모리 크기를 지정하거나, 이름을 붙히는 등 다양한 설정을 할 수 있다.

> println! 매크로는 내부에서 std::io::Stdout::lock()을 통해 출력 결과를 스레드 세이프하게 만든다.

# 스레드 수명 제한하기
`std::thread::spawn`는 `'static` 라이프 타임을 가진다. 하지면 특정 범위에서만 존재할 수 있도록 `std::thread::scope`를 제공한다.  
scope는 범위 안에만 존재하기 떄문에 로컬 변수의 소유권을 빌려올 수 있다. 이 패턴을 사용하면 **스레드가 범위 밖으로 나가지 못하는 것이 보장**되어 `'static`이 아닌 인수도 받을 수 있게 된다.
다음의 예는 spawn으로 생성했을 때 컴파일 에러가 발생했었지만 scope를 사용해서 문제를 해결했다.
```rust
fn main() {
    let non_static_value = 42;
    std::thread::scope(|s| {
        for i in 0..10 {
            println!("{}", i + non_static_value);
            std::thread::sleep(Duration::from_millis(10));
        }
        
        s.spawn(|| {
            for i in 0..10 {
                println!("{}", i + non_static_value);
                std::thread::sleep(Duration::from_millis(10));
            }
        });
    });
}
```
scope는 현재 범위를 나타내는 인수를 받는다. 위의 예는 s를 말한다.  
이 인수를 사용해 spawn을 호출하면 스레드의 범위도 scope 범위 안에서만 존재하도록 제한 할 수 있다.  
위 예제에서는 non_static_value가 불변이기 때문에 동시에 접근 하는 것이 가능하다. 하지만 만약 mutable이었을 경우 컴파일 오류가 발생한다.
![alt text](image-2.png)